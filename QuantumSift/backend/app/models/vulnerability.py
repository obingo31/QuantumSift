from enum import Enum, auto
from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime

class VulnerabilityType(str, Enum):
    """
    Comprehensive enumeration of smart contract vulnerability types
    """
    # Existing vulnerability types
    REENTRANCY = "Reentrancy"
    INTEGER_OVERFLOW = "Integer Overflow"
    ACCESS_CONTROL = "Access Control"
    ORACLE_MANIPULATION = "Oracle Manipulation"
    STATE_MANAGEMENT_VULNERABILITY = "State Management Vulnerability"
    OVERFLOW = "Overflow"
    UNDERFLOW = "Underflow"
    UNPROTECTED_SELFDESTRUCT = "Unprotected Selfdestruct"
    TIMESTAMP_DEPENDENCY = "Timestamp Dependency"
    DELEGATECALL = "Delegatecall"
    EXTERNAL_CONTRACT_REFERENCE = "External Contract Reference"
    RANDOMNESS = "Randomness"
    GAS_LIMIT = "Gas Limit"
    
    # New vulnerability types
    DATA_INTEGRITY_VULNERABILITY = "Data Integrity Vulnerability"
    PRICE_FEED_VULNERABILITY = "Price Feed Vulnerability"
    TOKEN_CONFIGURATION_VULNERABILITY = "Token Configuration Vulnerability"
    COLLATERAL_FACTOR_VULNERABILITY = "Collateral Factor Vulnerability"
    REDEMPTION_VULNERABILITY = "Redemption Vulnerability"
    CONTRACT_STATE_VULNERABILITY = "Contract State Vulnerability"

class VulnerabilitySeverity(Enum):
    LOW = auto()
    MEDIUM = auto()
    HIGH = auto()
    CRITICAL = auto()
    INFORMATIONAL = auto()

@dataclass
class StateUpdateAnalysis:
    """
    Detailed analysis of state update patterns and risks
    """
    total_state_updates: int = 0
    duplicate_updates: List[str] = field(default_factory=list)
    redundant_updates: List[str] = field(default_factory=list)
    update_locations: Dict[str, List[int]] = field(default_factory=dict)
    gas_inefficiency_score: float = 0.0
    
    def add_duplicate_update(self, update_key: str):
        """Add a detected duplicate state update"""
        if update_key not in self.duplicate_updates:
            self.duplicate_updates.append(update_key)
    
    def calculate_gas_inefficiency(self):
        """
        Calculate gas inefficiency based on duplicate and redundant updates
        
        :return: Gas inefficiency score (0.0 to 1.0)
        """
        total_updates = max(self.total_state_updates, 1)
        duplicate_weight = len(self.duplicate_updates) / total_updates
        redundant_weight = len(self.redundant_updates) / total_updates
        
        self.gas_inefficiency_score = min(
            (duplicate_weight * 0.6) + (redundant_weight * 0.4),
            1.0
        )
        return self.gas_inefficiency_score

@dataclass
class VulnerabilitySignature:
    """
    Represents a specific vulnerability signature
    """
    pattern: str
    description: str
    example_code: str
    state_update_analysis: Optional[StateUpdateAnalysis] = None

@dataclass
class VulnerabilityAuditReport:
    """
    Comprehensive vulnerability audit report
    """
    id: Optional[str] = None
    contract_name: str
    contract_address: Optional[str] = None
    blockchain: str
    vulnerability_type: VulnerabilityType
    severity: VulnerabilitySeverity
    signatures: List[VulnerabilitySignature]
    detected_lines: List[int] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.utcnow)
    mitigation_steps: List[str] = field(default_factory=list)
    
    def get_total_risk_score(self) -> float:
        """
        Calculate the overall risk score based on vulnerability severity
        
        :return: Risk score (0.0 to 1.0)
        """
        severity_mapping = {
            VulnerabilitySeverity.LOW: 0.25,
            VulnerabilitySeverity.MEDIUM: 0.5,
            VulnerabilitySeverity.HIGH: 0.75,
            VulnerabilitySeverity.CRITICAL: 1.0,
            VulnerabilitySeverity.INFORMATIONAL: 0.1
        }
        
        # Calculate average state update gas inefficiency
        state_update_inefficiency = sum(
            sig.state_update_analysis.gas_inefficiency_score 
            for sig in self.signatures 
            if sig.state_update_analysis
        ) / len(self.signatures) if self.signatures else 0
        
        return min(
            severity_mapping.get(self.severity, 0.5) * (1 + state_update_inefficiency),
            1.0
        )

    def to_dict(self):
        """Convert the report to a dictionary for storage"""
        return {
            "id": self.id,
            "contract_name": self.contract_name,
            "contract_address": self.contract_address,
            "blockchain": self.blockchain,
            "vulnerability_type": self.vulnerability_type,
            "severity": self.severity,
            "signatures": [sig.__dict__ for sig in self.signatures],
            "detected_lines": self.detected_lines,
            "timestamp": self.timestamp.isoformat(),
            "mitigation_steps": self.mitigation_steps
        }

@dataclass
class PriceManipulationSignature(VulnerabilitySignature):
    """
    Specialized signature for price manipulation vulnerabilities
    """
    price_impact_score: Optional[float] = None
    manipulation_vector: Optional[str] = None
    affected_tokens: Optional[List[str]] = None
    
    def calculate_risk_severity(self) -> VulnerabilitySeverity:
        """
        Calculate risk severity based on price manipulation potential
        
        :return: Vulnerability severity level
        """
        if self.price_impact_score is None:
            return VulnerabilitySeverity.MEDIUM
        
        severity_mapping = [
            (0.0, 0.2, VulnerabilitySeverity.LOW),
            (0.2, 0.5, VulnerabilitySeverity.MEDIUM),
            (0.5, 0.8, VulnerabilitySeverity.HIGH),
            (0.8, 1.1, VulnerabilitySeverity.CRITICAL)
        ]
        
        return next(
            severity for (low, high, severity) in severity_mapping
            if low <= self.price_impact_score < high
        )

@dataclass
class OraclePriceVulnerabilityReport(VulnerabilityAuditReport):
    """
    Specialized vulnerability report for oracle price manipulation
    """
    price_manipulation_signature: Optional[PriceManipulationSignature] = None
    
    def generate_detailed_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability report
        
        :return: Detailed vulnerability report dictionary
        """
        base_report = self.to_dict()
        
        if self.price_manipulation_signature:
            base_report.update({
                'price_impact_score': self.price_manipulation_signature.price_impact_score,
                'manipulation_vector': self.price_manipulation_signature.manipulation_vector,
                'affected_tokens': self.price_manipulation_signature.affected_tokens,
                'risk_severity': self.price_manipulation_signature.calculate_risk_severity()
            })
        
        return base_report

@dataclass
class CollateralFactorVulnerabilitySignature(VulnerabilitySignature):
    """
    Specialized signature for Collateral Factor vulnerabilities
    """
    creation_factor: Optional[float] = None
    liquidation_factor: Optional[float] = None
    risk_multiplier: Optional[float] = None
    
    def calculate_liquidation_risk(self) -> float:
        """
        Calculate the potential liquidation risk
        
        :return: Liquidation risk score between 0 and 1
        """
        if (self.creation_factor is None or 
            self.liquidation_factor is None):
            return 0.5  # Default moderate risk
        
        # Calculate risk based on factor proximity
        risk_score = 1 - (self.liquidation_factor / self.creation_factor)
        
        # Apply risk multiplier if provided
        if self.risk_multiplier is not None:
            risk_score *= self.risk_multiplier
        
        return min(max(risk_score, 0), 1)
    
    def generate_risk_description(self) -> str:
        """
        Generate a detailed risk description
        
        :return: Descriptive risk explanation
        """
        risk_score = self.calculate_liquidation_risk()
        
        risk_descriptions = {
            (0, 0.2): "Low Liquidation Risk: Collateral Factors provide robust protection",
            (0.2, 0.5): "Moderate Liquidation Risk: Potential vulnerabilities detected",
            (0.5, 0.8): "High Liquidation Risk: Immediate liquidation possible",
            (0.8, 1.1): "Critical Liquidation Risk: Systematic vulnerability"
        }
        
        return next(
            desc for (low, high), desc in risk_descriptions.items()
            if low <= risk_score < high
        )

@dataclass
class CollateralFactorVulnerabilityReport(VulnerabilityAuditReport):
    """
    Specialized vulnerability report for Collateral Factor issues
    """
    collateral_factor_signature: Optional[CollateralFactorVulnerabilitySignature] = None
    
    def generate_detailed_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability report
        
        :return: Detailed vulnerability report dictionary
        """
        base_report = self.to_dict()
        
        if self.collateral_factor_signature:
            base_report.update({
                'creation_factor': self.collateral_factor_signature.creation_factor,
                'liquidation_factor': self.collateral_factor_signature.liquidation_factor,
                'liquidation_risk_score': self.collateral_factor_signature.calculate_liquidation_risk(),
                'risk_description': self.collateral_factor_signature.generate_risk_description()
            })
        
        return base_report

@dataclass
class RedemptionVulnerabilitySignature(VulnerabilitySignature):
    """
    Specialized signature for redemption-related vulnerabilities
    """
    initial_token_balance: Optional[float] = None
    redeemable_amount: Optional[float] = None
    redemption_count: int = 0
    potential_drain_percentage: Optional[float] = None
    
    def calculate_vulnerability_score(self) -> float:
        """
        Calculate the vulnerability score based on redemption characteristics
        
        :return: Vulnerability score between 0 and 1
        """
        # Base score calculation
        if (self.initial_token_balance is None or 
            self.redeemable_amount is None):
            return 0.5  # Default moderate risk
        
        # Calculate potential drain risk
        drain_risk = min(
            (self.redeemable_amount / self.initial_token_balance) * self.redemption_count, 
            1.0
        )
        
        # Apply potential drain percentage if provided
        if self.potential_drain_percentage is not None:
            drain_risk *= self.potential_drain_percentage
        
        return drain_risk
    
    def generate_risk_description(self) -> str:
        """
        Generate a detailed risk description
        
        :return: Descriptive risk explanation
        """
        vulnerability_score = self.calculate_vulnerability_score()
        
        risk_descriptions = {
            (0, 0.2): "Low Redemption Risk: Minimal potential for token drainage",
            (0.2, 0.5): "Moderate Redemption Risk: Potential partial token drainage",
            (0.5, 0.8): "High Redemption Risk: Significant token drainage possible",
            (0.8, 1.1): "Critical Redemption Risk: Complete contract token drainage"
        }
        
        return next(
            desc for (low, high), desc in risk_descriptions.items()
            if low <= vulnerability_score < high
        )

@dataclass
class RedemptionVulnerabilityReport(VulnerabilityAuditReport):
    """
    Specialized vulnerability report for redemption-related issues
    """
    redemption_signature: Optional[RedemptionVulnerabilitySignature] = None
    
    def generate_detailed_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability report
        
        :return: Detailed vulnerability report dictionary
        """
        base_report = self.to_dict()
        
        if self.redemption_signature:
            base_report.update({
                'initial_token_balance': self.redemption_signature.initial_token_balance,
                'redeemable_amount': self.redemption_signature.redeemable_amount,
                'redemption_count': self.redemption_signature.redemption_count,
                'vulnerability_score': self.redemption_signature.calculate_vulnerability_score(),
                'risk_description': self.redemption_signature.generate_risk_description()
            })
        
        return base_report

@dataclass
class ContractStateVulnerabilitySignature(VulnerabilitySignature):
    """
    Specialized signature for contract state-related vulnerabilities
    """
    contract_state: Optional[str] = None  # e.g., 'paused', 'suspended'
    state_change_timestamp: Optional[datetime] = None
    affected_operations: Optional[List[str]] = None
    
    def calculate_state_risk(self) -> float:
        """
        Calculate the risk associated with contract state
        
        :return: Risk score between 0 and 1
        """
        # Default moderate risk if insufficient information
        if not self.contract_state or not self.affected_operations:
            return 0.5
        
        # Risk factors based on contract state
        state_risk_mapping = {
            'paused': 0.7,
            'suspended': 0.8,
            'disabled': 0.9,
            'inactive': 0.6
        }
        
        # Base risk from contract state
        base_risk = state_risk_mapping.get(
            self.contract_state.lower(), 
            0.5
        )
        
        # Adjust risk based on number of affected operations
        operation_risk_multiplier = min(
            len(self.affected_operations) / 10, 
            1.0
        )
        
        return min(base_risk * operation_risk_multiplier, 1.0)
    
    def generate_risk_description(self) -> str:
        """
        Generate a detailed risk description
        
        :return: Descriptive risk explanation
        """
        risk_score = self.calculate_state_risk()
        
        risk_descriptions = {
            (0, 0.2): "Low Contract State Risk: Minimal operational impact",
            (0.2, 0.5): "Moderate Contract State Risk: Some operational limitations",
            (0.5, 0.8): "High Contract State Risk: Significant operational constraints",
            (0.8, 1.1): "Critical Contract State Risk: Complete operational blockage"
        }
        
        return next(
            desc for (low, high), desc in risk_descriptions.items()
            if low <= risk_score < high
        )

@dataclass
class ContractStateVulnerabilityReport(VulnerabilityAuditReport):
    """
    Specialized vulnerability report for contract state-related issues
    """
    contract_state_signature: Optional[ContractStateVulnerabilitySignature] = None
    
    def generate_detailed_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability report
        
        :return: Detailed vulnerability report dictionary
        """
        base_report = self.to_dict()
        
        if self.contract_state_signature:
            base_report.update({
                'contract_state': self.contract_state_signature.contract_state,
                'state_change_timestamp': self.contract_state_signature.state_change_timestamp,
                'affected_operations': self.contract_state_signature.affected_operations,
                'state_risk_score': self.contract_state_signature.calculate_state_risk(),
                'risk_description': self.contract_state_signature.generate_risk_description()
            })
        
        return base_report

@dataclass
class ContractStateValidationSignature(VulnerabilitySignature):
    """
    Specialized signature for comprehensive contract state validation
    """
    contract_address: Optional[str] = None
    validation_checks: Optional[Dict[str, bool]] = None
    failed_checks: Optional[List[str]] = None
    
    def calculate_validation_risk(self) -> float:
        """
        Calculate the risk based on failed validation checks
        
        :return: Risk score between 0 and 1
        """
        # Default moderate risk if insufficient information
        if not self.validation_checks or not self.failed_checks:
            return 0.5
        
        # Calculate risk based on failed checks
        total_checks = len(self.validation_checks)
        failed_checks_count = len(self.failed_checks)
        
        # Risk increases with more failed checks
        base_risk = failed_checks_count / total_checks
        
        # Severity multipliers for critical checks
        critical_check_multipliers = {
            'is_paused': 1.5,
            'is_blacklisted': 1.7,
            'is_expired': 1.6
        }
        
        # Apply severity multipliers to critical failed checks
        for failed_check in self.failed_checks:
            base_risk *= critical_check_multipliers.get(
                failed_check, 
                1.0
            )
        
        return min(base_risk, 1.0)
    
    def generate_validation_report(self) -> str:
        """
        Generate a detailed validation report
        
        :return: Comprehensive validation report
        """
        if not self.validation_checks:
            return "No validation checks performed"
        
        report_lines = [
            f"Contract Address: {self.contract_address}",
            "Validation Checks:"
        ]
        
        for check, status in self.validation_checks.items():
            status_str = "✓ Passed" if status else "✗ Failed"
            report_lines.append(f"- {check}: {status_str}")
        
        if self.failed_checks:
            report_lines.append("\nFailed Checks:")
            for failed_check in self.failed_checks:
                report_lines.append(f"- {failed_check}")
        
        return "\n".join(report_lines)

@dataclass
class ContractStateValidationReport(VulnerabilityAuditReport):
    """
    Specialized vulnerability report for contract state validation
    """
    validation_signature: Optional[ContractStateValidationSignature] = None
    
    def generate_detailed_report(self) -> Dict[str, Any]:
        """
        Generate a comprehensive vulnerability report
        
        :return: Detailed vulnerability report dictionary
        """
        base_report = self.to_dict()
        
        if self.validation_signature:
            base_report.update({
                'contract_address': self.validation_signature.contract_address,
                'validation_checks': self.validation_signature.validation_checks,
                'failed_checks': self.validation_signature.failed_checks,
                'validation_risk_score': self.validation_signature.calculate_validation_risk(),
                'validation_report': self.validation_signature.generate_validation_report()
            })
        
        return base_report

class VulnerabilityDatabase:
    """In-memory database to store and match vulnerability reports"""
    def __init__(self):
        self._reports: List[VulnerabilityAuditReport] = []
    
    def add_report(self, report: VulnerabilityAuditReport):
        """Add a new vulnerability report"""
        self._reports.append(report)
    
    def find_similar_vulnerabilities(self, contract_code: str) -> List[VulnerabilityAuditReport]:
        """
        Find similar vulnerabilities by matching signatures against contract code
        
        :param contract_code: Source code of the smart contract
        :return: List of matching vulnerability reports
        """
        matched_reports = []
        
        for report in self._reports:
            for signature in report.signatures:
                if signature.pattern in contract_code:
                    matched_reports.append(report)
                    break
        
        return matched_reports
    
    def get_reports_by_severity(self, severity: VulnerabilitySeverity) -> List[VulnerabilityAuditReport]:
        """
        Retrieve reports matching a specific severity level
        
        :param severity: Severity level to filter
        :return: List of matching vulnerability reports
        """
        return [report for report in self._reports if report.severity == severity]
    
    def get_reports_by_type(self, vulnerability_type: VulnerabilityType) -> List[VulnerabilityAuditReport]:
        """
        Retrieve reports matching a specific vulnerability type
        
        :param vulnerability_type: Type of vulnerability to filter
        :return: List of matching vulnerability reports
        """
        return [report for report in self._reports if report.vulnerability_type == vulnerability_type]
