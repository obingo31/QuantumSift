from fastapi import APIRouter, File, UploadFile, HTTPException
from pydantic import BaseModel, Field
from typing import List, Optional
import uuid
from app.models.vulnerability import (
    VulnerabilityAuditReport, 
    VulnerabilityType, 
    VulnerabilitySeverity
)
from app.services.vulnerability_detector import VulnerabilityDetector

router = APIRouter()

class VulnerabilityModel(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type: str
    severity: str
    description: str
    mitigation: Optional[str] = None
    cwe_id: Optional[str] = None

class VulnerabilitySearchRequest(BaseModel):
    keyword: Optional[str] = None
    severity: Optional[str] = None
    blockchain: Optional[str] = None

# Global vulnerability database (in production, use a persistent database)
vulnerability_db = []

@router.post("/detect")
async def detect_vulnerabilities(contract_code: str):
    """
    Detect vulnerabilities in smart contract code
    """
    # Simulated vulnerability detection
    vulnerabilities = [
        VulnerabilityModel(
            type="Reentrancy",
            severity="High",
            description="Potential recursive call vulnerability",
            mitigation="Implement checks-effects-interactions pattern",
            cwe_id="CWE-841"
        ),
        VulnerabilityModel(
            type="Integer Overflow",
            severity="Medium",
            description="Potential arithmetic overflow risk",
            mitigation="Use SafeMath library or Solidity 0.8+ compiler",
            cwe_id="CWE-190"
        )
    ]
    
    return {
        "contract_code": contract_code,
        "vulnerabilities": vulnerabilities,
        "total_vulnerabilities": len(vulnerabilities)
    }

@router.get("/search")
async def search_vulnerabilities(request: VulnerabilitySearchRequest):
    """
    Search and filter known vulnerabilities
    """
    # Simulated vulnerability database
    all_vulnerabilities = [
        VulnerabilityModel(
            type="Reentrancy",
            severity="High",
            description="Allows recursive calls before state update",
            blockchain="Ethereum"
        ),
        VulnerabilityModel(
            type="Access Control",
            severity="Medium",
            description="Insufficient function access restrictions",
            blockchain="Solana"
        )
    ]
    
    # Filter vulnerabilities based on search criteria
    filtered_vulnerabilities = [
        vuln for vuln in all_vulnerabilities
        if (not request.keyword or request.keyword.lower() in vuln.type.lower()) and
           (not request.severity or request.severity == vuln.severity) and
           (not request.blockchain or request.blockchain == vuln.blockchain)
    ]
    
    return {
        "vulnerabilities": filtered_vulnerabilities,
        "total_results": len(filtered_vulnerabilities)
    }

@router.get("/{vulnerability_id}")
async def get_vulnerability_details(vulnerability_id: str):
    """
    Get detailed information about a specific vulnerability
    """
    # Simulated vulnerability details
    vulnerability = VulnerabilityModel(
        id=vulnerability_id,
        type="Reentrancy",
        severity="High",
        description="Detailed vulnerability description",
        mitigation="Comprehensive mitigation strategies",
        cwe_id="CWE-841"
    )
    
    return vulnerability

@router.post("/analyze")
async def analyze_smart_contract(
    file: UploadFile = File(...), 
    blockchain: str = "Ethereum"
) -> List[VulnerabilityAuditReport]:
    """
    Analyze a smart contract file for vulnerabilities
    
    :param file: Uploaded Solidity contract file
    :param blockchain: Blockchain platform
    :return: List of detected vulnerability reports
    """
    try:
        # Read file contents
        contract_code = await file.read()
        contract_code_str = contract_code.decode('utf-8')
        
        # Analyze contract
        vulnerabilities = VulnerabilityDetector.analyze_contract(contract_code_str)
        
        # Store vulnerabilities in database
        vulnerability_db.extend(vulnerabilities)
        
        return vulnerabilities
    
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.get("/reports")
async def get_vulnerability_reports(
    severity: VulnerabilitySeverity = None,
    vulnerability_type: VulnerabilityType = None
) -> List[VulnerabilityAuditReport]:
    """
    Retrieve vulnerability reports with optional filtering
    
    :param severity: Filter by vulnerability severity
    :param vulnerability_type: Filter by vulnerability type
    :return: List of vulnerability reports
    """
    filtered_reports = vulnerability_db
    
    if severity:
        filtered_reports = [
            report for report in filtered_reports 
            if report.severity == severity
        ]
    
    if vulnerability_type:
        filtered_reports = [
            report for report in filtered_reports 
            if report.vulnerability_type == vulnerability_type
        ]
    
    return filtered_reports

@router.get("/types")
async def get_vulnerability_types() -> List[str]:
    """
    Get all supported vulnerability types
    
    :return: List of vulnerability type names
    """
    return [vtype.value for vtype in VulnerabilityType]
