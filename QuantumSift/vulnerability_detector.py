from eth_utils import is_address, to_checksum_address
from transformers import AutoTokenizer, AutoModel
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
import json

class VulnerabilityDetector:
    def __init__(self, model_name="sentence-transformers/all-MiniLM-L6-v2"):
        """
        Initialize the vulnerability detector with a pre-trained transformer model
        
        Args:
            model_name (str): Hugging Face model for embeddings
        """
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name)
        
        # Predefined vulnerability patterns
        self.vulnerability_patterns = [
            {
                "type": "Reentrancy",
                "description": "Vulnerability where an external contract call can recursively call back into the current contract before state is updated",
                "risk_score": 0.9
            },
            {
                "type": "Integer Overflow",
                "description": "Vulnerability where arithmetic operations can cause unexpected behavior due to integer limits",
                "risk_score": 0.7
            },
            {
                "type": "Access Control",
                "description": "Improper access control allowing unauthorized actions",
                "risk_score": 0.8
            },
            {
                "type": "Unchecked External Call",
                "description": "Making external calls without checking return values or handling potential failures",
                "risk_score": 0.6
            }
        ]
    
    def get_embedding(self, text):
        """
        Generate embedding for a given text
        
        Args:
            text (str): Input text to embed
        
        Returns:
            numpy.ndarray: Embedding vector
        """
        tokens = self.tokenizer(text, return_tensors="pt", truncation=True, padding=True)
        outputs = self.model(**tokens)
        return outputs.last_hidden_state.mean(dim=1).detach().numpy()
    
    def detect_vulnerabilities(self, contract_code):
        """
        Detect potential vulnerabilities in contract code
        
        Args:
            contract_code (str): Smart contract source code
        
        Returns:
            list: Detected vulnerabilities with details
        """
        contract_emb = self.get_embedding(contract_code)
        detected_vulnerabilities = []
        
        for pattern in self.vulnerability_patterns:
            pattern_emb = self.get_embedding(pattern['description'])
            similarity = cosine_similarity(contract_emb, pattern_emb)[0][0]
            
            if similarity > 0.5:  # Adjustable threshold
                detected_vulnerabilities.append({
                    "type": pattern['type'],
                    "description": pattern['description'],
                    "risk_score": pattern['risk_score'],
                    "similarity": float(similarity)
                })
        
        return detected_vulnerabilities
    
    def analyze_contract(self, contract_code):
        """
        Comprehensive contract analysis
        
        Args:
            contract_code (str): Smart contract source code
        
        Returns:
            dict: Analysis results
        """
        vulnerabilities = self.detect_vulnerabilities(contract_code)
        
        return {
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "overall_risk": max([v['risk_score'] for v in vulnerabilities]) if vulnerabilities else 0
        }

def main():
    # Example usage
    detector = VulnerabilityDetector()
    
    example_contract = """
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }
    """
    
    results = detector.analyze_contract(example_contract)
    print(json.dumps(results, indent=2))

if __name__ == "__main__":
    main()
